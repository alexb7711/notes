<!DOCTYPE html>
<html>
<head>
    <title>dockerfile</title>
    <link href="style.css" rel="stylesheet">
</head>
<body>
<div id="navigation">
<ul>
<li><a class="%blog.html%" href="blog.html">blog</a></li>
<li><a class="%notes.html%" href="notes.html">notes</a></li>
<li><a class="%projects.html%" href="projects.html">projects</a></li>
<li><a class="%index.md%" href="index.html">index</a></li>
</ul>
</div>

<div class="content">
<!-- :docker: -->
<h1 id="dockerfile-overview">Dockerfile Overview</h1>
<p>Docker builds images by reading the instructions from a Dockerfile. A Dockerfile is a text file containing instructions for building your source code.</p>
<h2 id="filename">Filename</h2>
<p>The default filename is <code>Dockerfile</code>. When the default filename is used, when you run <code>docker build</code>, the <code>Dockerfile</code> is utilized.</p>
<h1 id="docker-images">Docker Images</h1>
<p>Docker images consist of layers. Each layer is the result of a build instruction in the Dockerfile. Layers are stacked sequentially, and each one is a delta representing the changes applied to the previous layer.</p>
<h2 id="example">Example</h2>
<pre class="codehilite"><code class="language-Docker"># Instructs the docer builder what version
# syntax to use.
# `docker/dockerfile:1` points to the
# latest release of the version 1 syntax.
# syntax=docker/dockerfile:1

# Specify the OS:VERSION used in the Docker image
# There are public images available at the Docker Hub.
# Local images may also be used.
FROM ubuntu:22.04

# install app dependencies
RUN apt-get update &amp;&amp; apt-get install -y python3 python3-pip
RUN pip install flask==3.0.*

# install app
# By doing this, `hello.py` is added to the build context of
# the Docker image. The build context is the set of files
# that the build can access.
COPY hello.py /

# final configuration
# If the application uses enviornment variables, you can
# set them this way.
ENV FLASK_APP=hello

# Mark that the final image has a service listening on port 8000
EXPOSE 8000

# Start the application
# The `CMD` instruction sets the command that is run when the
# user starts a container based on this image.
CMD [&quot;flask&quot;, &quot;run&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]
</code></pre>

<h1 id="building">Building</h1>
<p>To build the container image using the Dockerfile created previously, you would run the command</p>
<pre class="codehilite"><code class="language-shell">docker build -t test:latest .
</code></pre>

<p>The <code>-t test:latest</code>  option specifies the name and tag of the image.</p>
<p>The single dot at the end of the command sets the build context to the current directory. This means that the <code>hello.py</code> file needs to be in the same directory as to where tho command is being invoked.</p>
<p>After the image has been built, the application can be run as a container with</p>
<pre class="codehilite"><code>docker run -p 127.0.0.1:8000:8000 test:latest
</code></pre>

<p>This publishes the container's port <code>8000</code> to <code>https://localhost:8000</code> on the Docker host.</p>
<h1 id="common-instructions">Common Instructions</h1>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FROM &lt;image&gt;</code></td>
<td>Defines a base for your image.</td>
</tr>
<tr>
<td><code>RUN &lt;command&gt;</code></td>
<td>Executes any commands in a new layer on top of the current image and commits the result. <code>RUN</code> also has a shell form for running commands.</td>
</tr>
<tr>
<td><code>WORKDIR &lt;directory&gt;</code></td>
<td>Sets the working directory for any <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code>, and <code>ADD</code> instructions that follow it in the Dockerfile.</td>
</tr>
<tr>
<td><code>COPY &lt;src&gt; &lt;dest&gt;</code></td>
<td>Copies new files or directories from <code>&lt;src&gt;</code> and adds them to the filesystem of the container at the path <code>&lt;dest&gt;</code>.</td>
</tr>
<tr>
<td><code>CMD &lt;command&gt;</code></td>
<td>Lets you define the default program that is run once you start the container based on this image. Each Dockerfile only has one <code>CMD</code>, and only the last <code>CMD</code> instance is respected when multiple exist.</td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<p>- <a href="https://docs.docker.com/build/concepts/dockerfile/">https://docs.docker.com/build/concepts/dockerfile/</a></p>
<p>- <a href="https://docs.docker.com/build/concepts/context/">https://docs.docker.com/build/concepts/context/</a></p>
</div>
<footer>
<p>Generated by Pymind: 2025-07-26</p>
</footer>

</body>
</html>
